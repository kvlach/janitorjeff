package tiktok

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"errors"
	"io/ioutil"
	"net/http"
	"net/url"

	"github.com/janitorjeff/jeff-bot/core"
	"github.com/janitorjeff/jeff-bot/frontends"

	"github.com/janitorjeff/gosafe"
)

var Hooks = gosafe.Map[string, int]{}

var (
	ErrHookNotFound   = errors.New("Wasn't monitoring, what are you even trynna do??")
	ErrPersonNotFound = errors.New("Person's voice has not been set.")
)


type TTSResp struct {
	Data struct {
		SKey     string `json:"s_key"`
		VStr     string `json:"v_str"`
		Duration string `json:"duration"`
		Speaker  string `json:"speaker"`
	} `json:"data"`
	Extra struct {
		LogID string `json:"log_id"`
	} `json:"extra"`
	Message    string `json:"message"`
	StatusCode int    `json:"status_code"`
	StatusMsg  string `json:"status_msg"`
}

// TTS will return a slice of bytes containing the audio generated by the TikTok
// TTS. You need to have the TikTokSessionID global set.
func TTS(voice, text string) ([]byte, error) {
	reqURL := "https://api16-normal-useast5.us.tiktokv.com/media/api/text/speech/invoke/?"
	reqURL += "text_speaker=" + voice
	reqURL += "&req_text=" + url.QueryEscape(text)
	reqURL += "&speaker_map_type=0&aid=1233"

	client := &http.Client{}
	req, err := http.NewRequest("POST", reqURL, nil)
	if err != nil {
		return nil, err
	}

	req.Header = http.Header{
		"Cookie": {"sessionid=" + core.TikTokSessionID},
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var data TTSResp
	err = json.Unmarshal(body, &data)
	if err != nil {
		return nil, err
	}

	decoded, err := base64.StdEncoding.DecodeString(data.Data.VStr)
	if err != nil {
		return nil, err
	}

	return decoded, nil
}

// Play will, if necessary join the appropriate voice channel, and start playing
// the TTS specified by text.
func Play(sp core.AudioSpeaker, voice, text string) error {
	audio, err := TTS(voice, text)
	if err != nil {
		return err
	}

	err = sp.Join()
	if err != nil {
		return err
	}

	state := &core.AudioState{}
	state.Set(core.AudioPlay)

	buf := ioutil.NopCloser(bytes.NewReader(audio))
	core.AudioFFmpegBufferPipe(sp, buf, state)

	return nil
}

// Start will create a hook and will monitor all incoming messages, if they
// are from twitch and match the specified username then the the TTS audio will
// be sent to the specified speaker.
func Start(sp core.AudioSpeaker, twitchUsername string) {
	id := core.Hooks.Register(func(m *core.Message) {
		if m.Frontend != frontends.Twitch || m.Here.Name() != twitchUsername {
			return
		}

		author, err := m.Author.Scope()
		if err != nil {
			return
		}

		here, err := m.Here.ScopeLogical()
		if err != nil {
			return
		}

		voice := MustUserVoiceGet(author, here)

		Play(sp, voice, m.Raw)
	})
	Hooks.Set(twitchUsername, id)
}

// Stop will delete the hook created by Start. Returns ErrHookNotFound if the
// hook doesn't exist.
func Stop(twitchUsername string) error {
	id, ok := Hooks.Get(twitchUsername)
	if !ok {
		return ErrHookNotFound
	}
	core.Hooks.Delete(id)
	Hooks.Delete(twitchUsername)
	return nil
}

// UserVoiceGet returns the person's voice in this place. Returns
// ErrPersonNotFound if no voice has been set.
func UserVoiceGet(person, place int64) (string, error, error) {
	exists, err := dbPersonExists(person, place)
	if err != nil {
		return "", nil, err
	}
	if !exists {
		return "", ErrPersonNotFound, nil
	}
	voice, err := dbPersonGetVoice(person, place)
	return voice, nil, err
}

// MustUserVoiceGet works like UserVoiceGet the only difference being that if
// no voice has been set in this place for the person then it returns the
// default en_us_002 voice.
func MustUserVoiceGet(person, place int64) string {
	usrVoice, usrErr, err := UserVoiceGet(person, place)
	if usrErr == nil && err == nil {
		return usrVoice
	}
	return "en_us_002"
}

// UserVoiceSet sets the user voice.
func UserVoiceSet(person, place int64, voice string) error {
	exists, err := dbPersonExists(person, place)
	if err != nil {
		return err
	}
	if exists {
		return dbPersonUpdateVoice(person, place, voice)
	}
	return dbPersonAddVoice(person, place, voice)
}
